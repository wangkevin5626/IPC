///////////////////////////////////////////////////////////
/// @file	ByteBuffer.h
/// @brief	Byteバッファ
/// @author	shuji-morimoto
/// Copyright (C) 2013- Mamezou. All rights reserved.
///////////////////////////////////////////////////////////

#ifndef __PICO_IPC_BYTE_BUFFER_
#define __PICO_IPC_BYTE_BUFFER_

#include <string>
#include <vector>
#include <map>
#include <cstdio>
#include <cstdarg>
#include <cstring>

namespace PicoIPC {
///////////////////////////////////////////////////////////
/// @class ByteBuffer
/// @brief	Byteバッファ
/// @note プリミティブ型、string, vector, mapをバイト配列で管理する<br />
///////////////////////////////////////////////////////////
class ByteBuffer {
public:
	///////////////////////////////////////////////////////////
	/// @brief		コンストラクタ
	/// @param[in]	_reserve バッファ拡張時のサイズ
	/// @return		なし
	/// @note
	///////////////////////////////////////////////////////////
	ByteBuffer(int _reserve = 2048);

	///////////////////////////////////////////////////////////
	/// @brief		コンストラクタ
	/// @param[in]	_data 初期データ
	/// @param[in]	_reserve バッファ拡張時のサイズ
	/// @return		なし
	/// @note		const std::string &Data() constで取得したstd::stringを<br/>
	/// 			指定することでByteBufferを復元できる
	///////////////////////////////////////////////////////////
	ByteBuffer(const std::string &_data, int _reserve = 2048);

	///////////////////////////////////////////////////////////
	/// @brief		コンストラクタ
	/// @param[in]	_data 初期データ
	/// @param[in]	_size データサイズ
	/// @param[in]	_reserve バッファ拡張時のサイズ
	/// @return		なし
	/// @note		const std::string &Data() constで取得した値のchar配列を<br/>
	/// 			指定することでByteBufferを復元できる
	///////////////////////////////////////////////////////////
	ByteBuffer(const char *_data, size_t _size, int _reserve = 2048);

	///////////////////////////////////////////////////////////
	/// @brief		デストラクタ
	/// @return		なし
	/// @note
	///////////////////////////////////////////////////////////
	~ByteBuffer();

	///////////////////////////////////////////////////////////
	/// @brief		バッファが空かどうか確認する
	/// @return		空のときtrue
	/// @note
	///////////////////////////////////////////////////////////
	bool IsEmpty() const;

	///////////////////////////////////////////////////////////
	/// @brief		バッファの現在サイズを取得する
	/// @return		現在サイズ
	/// @note
	///////////////////////////////////////////////////////////
	size_t Size() const;

	///////////////////////////////////////////////////////////
	/// @brief		バッファをクリアする
	/// @return		なし
	/// @note
	///////////////////////////////////////////////////////////
	void Clear();

	///////////////////////////////////////////////////////////
	/// @brief		バッファ内容を文字列で取得する
	/// @return		バイトデータ
	/// @note		シリアライズされた生データ<br/>
	/// 			ByteBufferのコンストラクタに渡すことでByteBufferを復元できる
	///////////////////////////////////////////////////////////
	const std::string &Data() const;

	///////////////////////////////////////////////////////////
	/// @brief		ByteBufferを追加する
	/// @param[in]	_data 書き込むデータ
	/// @note
	///////////////////////////////////////////////////////////
	void Append(ByteBuffer &_data);

	///////////////////////////////////////////////////////////
	/// @brief		文字列(std::string)を追加する
	/// @param[in]	_data 書き込むデータ
	/// @note
	///////////////////////////////////////////////////////////
	void Append(const std::string &_data);

	///////////////////////////////////////////////////////////
	/// @brief		文字列(const char *)を追加する
	/// @param[in]	_data 書き込むデータ
	/// @note		null('\0')ターミネートしていること
	///////////////////////////////////////////////////////////
	void Append(char *_data);

	///////////////////////////////////////////////////////////
	/// @brief		フォーマットされた文字列を追加する
	/// @param[in]	_format フォーマット
	/// @param[in]	_args 可変長引数
	/// @note		ex) buf.Append("[%04d] %s", lineNo, message.c_str());
	///////////////////////////////////////////////////////////
	void Append(const char *_format, ...);

	///////////////////////////////////////////////////////////
	/// @brief		size_tを追加する
	/// @param[in]	_data 書き込むデータ
	/// @note		データはsizeof(int)に収まる値であること
	///////////////////////////////////////////////////////////
	void Append(size_t _data);

	///////////////////////////////////////////////////////////
	/// @brief		std::vector<T>を追加する
	/// @param[in]	_data 書き込むデータ
	/// @note
	/// 要素Tはプリミティブ型またはプリミティブ型のみで構成された構造体のみサポート
	///////////////////////////////////////////////////////////
	template <class T>
	void Append(const std::vector<T> &_data)
	{
		// std::vector<T>はサイズと要素をまとめて追加する
		int v = _data.size();
		Append(v);
		for (int i = 0; i < v; i++) {
			Append(_data.at(i));
		}
	}

	///////////////////////////////////////////////////////////
	/// @brief		std::map<K,V>を追加する
	/// @param[in]	_data 書き込むデータ
	/// @return		ByteBuffer
	/// キーK,要素Vはプリミティブ型またはプリミティブ型のみで構成された構造体のみサポート
	///////////////////////////////////////////////////////////
	template <class K, class V>
	void Append(const std::map<K,V> &_data)
	{
		// std::map<K,V>はサイズとkey,valueをまとめて追加する
		// テンプレートパラメータではtypenameが必要(らしい)
		const typename std::map<K,V> &m = _data;
		int v = m.size();
		Append(v);
		typename std::map<K,V>::const_iterator ite = _data.begin();
		typename std::map<K,V>::const_iterator end = _data.end();
		for (; ite != end; ite++) {
			Append(ite->first);
			Append(ite->second);
		}
	}

	///////////////////////////////////////////////////////////
	/// @brief		データ型Tを追加する
	/// @param[in]	_data 書き込むデータ
	/// @note
	/// std::vector, std::map, std::stringは要素数も追加する
	/// sizeof(T)で計算できないためプリミティブ型 または 要素がプリミティブ型で
	/// 構成された構造体 のみ利用すること<br />
	///////////////////////////////////////////////////////////
	template <class T>
	void Append(T _data)
	{
		mBuffer.append(reinterpret_cast<const char*>(&_data), sizeof(_data));
	}

	///////////////////////////////////////////////////////////
	/// @brief		ByteBufferを取得する
	/// @param[out]	_out データ
	/// @note		Append()した順で取り出すこと <br />
	///////////////////////////////////////////////////////////
	void Value(ByteBuffer &_out);

	///////////////////////////////////////////////////////////
	/// @brief		文字列(std::string)を取得する
	/// @param[out]	_out データ
	/// @note		Append()した順で取り出すこと <br />
	///////////////////////////////////////////////////////////
	void Value(std::string &_out);

	///////////////////////////////////////////////////////////
	/// @brief		文字列(char *)を取得する
	/// @param[out]	_out データ
	/// @note		Append()した順で取り出すこと <br />
	///////////////////////////////////////////////////////////
	void Value(char *_out);

	///////////////////////////////////////////////////////////
	/// @brief		size_t型で値を取得する
	/// @param[out]	_out データ
	/// @note		Append()した順で取り出すこと <br />
	///////////////////////////////////////////////////////////
	void Value(size_t &_out);

	///////////////////////////////////////////////////////////
	/// @brief		std::vector<T>を取得する
	/// @param[out]	_out データ
	/// @note		Append()した順で取り出すこと <br />
	///////////////////////////////////////////////////////////
	template <class T>
	void Value(std::vector<T> &_out)
	{
		// vectorのサイズと要素をまとめて取得する
		int size = 0;
		Value(size);
		for (int i = 0; i < size; i++) {
			T value;
			Value(value);
			_out.push_back(value);
		}
	}

	///////////////////////////////////////////////////////////
	/// @brief		std::map<K,V>を取得する
	/// @param[out]	_out データ
	/// @note		Append()した順で取り出すこと <br />
	///////////////////////////////////////////////////////////
	template <class K, class V>
	void Value(std::map<K,V> &_out)
	{
		// std::map<K,V>のサイズとkey,valueをまとめて取得する
		int size = 0;
		Value(size);
		for (int i = 0; i < size; i++) {
			K key;
			Value(key);
			V val;
			Value(val);
			_out.insert(std::make_pair(key,val));
		}
	}

	///////////////////////////////////////////////////////////
	/// @brief		データ型Tを取得する
	/// @param[out]	_out データ
	/// @note		Append()した順で取り出すこと <br />
	///////////////////////////////////////////////////////////
	template <class T>
	void Value(T &_out)
	{
		int size = sizeof(_out);
		::memcpy(&_out, mBuffer.data() + mPosition, size);
		mPosition += size;
	}

	///////////////////////////////////////////////////////////
	/// @brief		データポインタの位置を取得する
	/// @return		データポインタの位置
	/// @note		
	///////////////////////////////////////////////////////////
	unsigned int Position() const;

	///////////////////////////////////////////////////////////
	/// @brief		データポインタの位置を指定した位置に移動する
	/// @param[int]	pos 位置
	/// @note		
	///////////////////////////////////////////////////////////
	void SetPosition(unsigned int pos);

	///////////////////////////////////////////////////////////
	/// @brief		16進ダンプを取得する
	/// @return		16進ダンプ
	/// @note		
	///////////////////////////////////////////////////////////
	std::string Dump() const;

	///////////////////////////////////////////////////////////
	/// @brief		標準出力に16進ダンプする
	/// @note		
	///////////////////////////////////////////////////////////
	void Print() const;

	///////////////////////////////////////////////////////////
	/// @brief		標準出力に16進ダンプする
	/// @param[int]	title タイトル
	/// @note		
	///////////////////////////////////////////////////////////
	void Print(const std::string &title) const;

private:
	/// 内部バッファ
	std::string mBuffer;

	/// データポインタ位置
	unsigned int mPosition;
};
}

#endif
