///////////////////////////////////////////////////////////
/// @file	Thread.h
/// @brief	スレッド
/// @author	shuji-morimoto
/// Copyright (C) 2013- Mamezou. All rights reserved.
///////////////////////////////////////////////////////////

#ifndef __PICO_IPC_THREAD__
#define __PICO_IPC_THREAD__

#include <pthread.h>
#include <string>

namespace PicoIPC {

///////////////////////////////////////////////////////////
/// @class	IRunnable
/// @brief	スレッド処理インタフェース
/// 
/// - Threadクラスはスレッドの管理を行い、実際の処理はIRunnable::Run()で行う
///   IRunnableを実装したクラスはいわゆる作業者[Worker]クラスと呼ばれる
/// - このインタフェースを実装してスレッド処理を実装する
/// - スレッド開始時にRun()メソッドがコールされる
/// - スレッド終了時/キャンセル時にCleanup()メソッドがコールされる(デフォルトは何もしない)
///
/// Run()でスレッド処理が開始されているときMutexをLock()したまま
/// Cancel()がコールされると、以後そのMutexはLockされたままになり、
/// デッドロックが発生する可能性がある。
/// Cleanup()はMutexをUnlock()するといった使い方を想定
///
///////////////////////////////////////////////////////////
class IRunnable
{
public:
	///////////////////////////////////////////////////////////
	/// @brief		デストラクタ
	///////////////////////////////////////////////////////////
	virtual ~IRunnable() {};

	///////////////////////////////////////////////////////////
	/// @brief		スレッド処理を実装する
	///
	/// Run()が終えるとスレッドが終了する。スレッドを継続するには
	/// Run()から抜けないようにループ処理等を記述する。
	/// スリープや待機処理を適切に記述し、システムの負荷を上げない
	/// よう注意すること。
	///
	/// Thread::Cancel()がコールされると、Run()の処理中でも突然
	/// Run()が終えてしまうことに注意すること。
	///
	///////////////////////////////////////////////////////////
	virtual void Run() = 0;

	///////////////////////////////////////////////////////////
	/// @brief		スレッド処理終了後またはキャンセル後に実施する処理を実装する
	///
	/// デフォルトは何もしない
	///
	///////////////////////////////////////////////////////////
	virtual void Cleanup() {};
};


///////////////////////////////////////////////////////////
/// @class	Thread
/// @brief	スレッド
/// 
/// - ThreadはPOSIX スレッドの代理クラスとなる
/// - 主にStart()/Cancel()/Join()でスレッドのライフサイクルを管理する
/// - IRunnableではなく、このクラスを継承してスレッド処理を実装することもできる
///
///  [ライフサイクル]
///   <Start> ---> <コンストラクタ> --> <A> ---> <デストラクタ> --> <End>
/// 
///         +---------<-------------------<-----------------<--------+
///         |                                                        |loop
///   <A> -----+------>----------+-------->---------+------->--------+------->
///            |              |  |               |  |             |
///            +--> Start() --+  +--> Cancel() --+  +--> Join() --+
/// 
///   - <Start>から<A>前まではスレッド処理が開始されていないので非アクティブ状態(IsActive() == false)
///            之前没有开始线程处理，所以不激活状态
///   - Start()直後からスレッド処理が開始されアクティブ状態(IsActive() == true)
///             立即开始了线程处理的活动状态
///   - Cancel()終了後はすぐにはスレッド処理が終了していないことに注意(IsActive() は不定)
///             注意结束后的线程处理没有结束
///   - Join()終了後はスレッド処理が終了しており、非アクティブ状態(IsActive() == false)
///          结束后的线程处理结束，非活动状态
///  [スレッドの状態と制御]
///   同じThreadはloopで何度もスレッド処理が可能だがIsActive()の状態により制御が変わる
///   - Start() : アクティブな状態(IsActive() == true)のときは何もしない
///               活跃的状态                                   那时候什么也不做
///   - Cancel(): 非アクティブな状態(IsActive() == false)のときは何もしない
///   - Join()  : 非アクティブな状態(IsActive() == false)のときは何もしない
/// 
///////////////////////////////////////////////////////////
class Thread
{
public:
	///////////////////////////////////////////////////////////
	/// @brief		このメソッドを呼び出したスレッドを取得する
	/// @return		Thread
	/// @note		ThreadやIRunnable内から呼び出すことを想定
	/// @note		mainスレッドやThreadやIRunnable以外のスレッドから呼び出したときはNULLが返る
	///////////////////////////////////////////////////////////
	static Thread *CurrentThread();

	///////////////////////////////////////////////////////////
	/// @brief		このメソッドを呼び出したスレッドのスレッドIDを取得する
	/// @return		スレッドID
	/// @note		
	///////////////////////////////////////////////////////////
	static unsigned long CurrentThreadId(); // current thread id

	///////////////////////////////////////////////////////////
	/// @brief		このメソッドを呼び出したスレッドのCPUを開放し、他のスレッドにCPUを明け渡す
    ///             打开这个方法的线程的CPU，将CPU让给其他的线程
	/// @note		OSのスレッドコンテキストの切り替えが起こり、<br/>
    ///             OS的线程的切换发生
	/// 			システム性能が劣化する場合があるため適切に利用すること
    ///             因为系统性能有恶化的情况，所以要适当利用
	///////////////////////////////////////////////////////////
	static void Yield();

	///////////////////////////////////////////////////////////
	/// @brief		このメソッドを呼び出したスレッドを指定秒停止する
	/// @param[in]	sec 秒
	/// @note		
	///////////////////////////////////////////////////////////
	static void Sleep(unsigned int sec);

	///////////////////////////////////////////////////////////
	/// @brief		このメソッドを呼び出したスレッドを指定ミリ(10^-3)秒停止する
	/// @param[in]	millisec ミリ秒
	/// @note		
	///////////////////////////////////////////////////////////
	static void MilliSleep(unsigned int millisec);

	///////////////////////////////////////////////////////////
	/// @brief		このメソッドを呼び出したスレッドを指定マイクロ(10^-6)秒停止する
	/// @param[in]	microsec マイクロ秒
	/// @note		
	///////////////////////////////////////////////////////////
	static void MicroSleep(unsigned int microsec);

	///////////////////////////////////////////////////////////
	/// @brief		このメソッドを呼び出したスレッドを指定ナノ(10^-9)秒停止する
	/// @param[in]	nsec ナノ秒
	/// @note		
	///////////////////////////////////////////////////////////
	static void NanoSleep(unsigned int nsec);


	///////////////////////////////////////////////////////////
	/// @brief		コンストラクタ
	/// @note		何もしないスレッド(スタック変数としての利用を想定)
	/// @note		後でSetRunner()でIRunnableとパラメータを設定可能
	//////////////////////////////////////////////////////////
	Thread();

	///////////////////////////////////////////////////////////
	/// @brief		コンストラクタ
	/// @param[in]	runnable IRunnableインタフェース
	/// @param[in]	param パラメータ
	/// @note		IRunnableとIRunnable::Run()内で取得するパラメータを設定する
	///////////////////////////////////////////////////////////
	Thread(IRunnable *runnable, void *param);

	///////////////////////////////////////////////////////////
	/// @brief		デストラクタ
	///////////////////////////////////////////////////////////
	virtual ~Thread();

	///////////////////////////////////////////////////////////
	/// @brief		IRunnableとパラメータを設定する
	/// @param[in]	runnable IRunnableインタフェース
	/// @param[in]	param パラメータ
	/// @note		Start()をコールする前に設定すること
	///////////////////////////////////////////////////////////
	void SetRunner(IRunnable *runnable, void *param);

	///////////////////////////////////////////////////////////
	/// @brief		パラメータを取得する
	/// 
	/// Threadのコンストラクタで渡したパラメータはIRunnable::Run()内から
	/// void Run() {
	///     Thread *t = Thread::CurrentThread();
	///     MyParameter *param = static_cast<MyParameter*>(t->Parameter());
	///        :
	/// として取得できる
	/// 
	/// @return		パラメータ
    ///             参数
	/// @note		static_castして取得すること
    ///                           进行取得
	///////////////////////////////////////////////////////////
	void *Parameter();

	///////////////////////////////////////////////////////////
	/// @brief		名前を設定する
	/// @param[in]	name 名前
	/// @note		最大16文字
	///////////////////////////////////////////////////////////
	void SetName(const std::string &name);

	///////////////////////////////////////////////////////////
	/// @brief		名前を取得する
	/// @return		名前
	/// @note		デフォルトは""
	///////////////////////////////////////////////////////////
	std::string Name();

	///////////////////////////////////////////////////////////
	/// @brief		スレッドIDを取得する
	/// @return		スレッドID
	/// @note		Start()していない場合は0
	/// @note		マルチスレッドでの重複はないが、スレッドが終了した場合、
	/// 			別のスレッドで再利用されることがあることに注意
	///////////////////////////////////////////////////////////
	unsigned long ThreadId();

	///////////////////////////////////////////////////////////
	/// @brief		スレッドがアクティブか確認する
	/// @retval		true アクティブ
	/// @retval		false 非アクティブ
	/// @note		Start()前はfalse,Join()後はfalseとなるが<br/>
	/// 			Start()後からJoin()前まではスレッドの状態による
	///////////////////////////////////////////////////////////
	bool IsActive();

	///////////////////////////////////////////////////////////
	/// @brief		スレッド処理をThreadを継承して利用する場合はこのメソッドをoverrideする
	/// @note		
	///////////////////////////////////////////////////////////
	virtual void Execute();

	///////////////////////////////////////////////////////////
	/// @brief		リソース開放処理を継承して利用する場合はこのメソッドをoverrideする
	/// @note		
	///////////////////////////////////////////////////////////
	virtual void Cleanup();

	///////////////////////////////////////////////////////////
	/// @brief		スレッド処理の開始を要求する
	/// @note		スレッド処理が開始する前に戻る(non block)
	/// @note		IsActive()がtrueの場合は何もしない
	///////////////////////////////////////////////////////////
	void Start();

	///////////////////////////////////////////////////////////
	/// @brief		スレッド処理のキャンセルを要求する
	/// @note		スレッド処理が終了する前に戻る(non block)
	/// @note		すでにスレッド処理が終了している場合は何もしない
	///////////////////////////////////////////////////////////
	void Cancel();

	///////////////////////////////////////////////////////////
	/// @brief		スレッド処理が終了するかキャンセルするまで待機する
	/// @note		すでにスレッド処理が終了している場合は何もしない
	///////////////////////////////////////////////////////////
	void Join();

private:
	///////////////////////////////////////////////////////////
	/// @brief		コピーコンストラクタ
	/// @note		コピー禁止
	///////////////////////////////////////////////////////////
	Thread(const Thread &src);

	///////////////////////////////////////////////////////////
	/// @brief		代入オペレータ
	/// @note		代入禁止
	///////////////////////////////////////////////////////////
	Thread &operator =(const Thread &src);

	pthread_t      mThread;    ///< POSIX スレッド
	IRunnable     *mRunnable;  ///< IRunnableインタフェース
	void          *mParameter; ///< パラメータ
	std::string    mName;      ///< 名前
	unsigned long  mThreadId;  ///< スレッドID
	bool           mIsActive;  ///< 活性化状態
};
}
#endif
